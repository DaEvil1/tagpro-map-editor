<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>TagPro Map Editor</title>
		<script src="generatepng.js"></script>
		<script src="webtoolkit.base64.js"></script>
		<script src="jquery-2.1.0.min.js"></script>

<style type="text/css">
div.tileRow {
  height:40px;
}
div.tile {
  width:40px;
  height:40px;
  background-image: url("default-skin.png"); 
  display:inline-block;
}
div.tileBackground {
  width:40px;
  height:40px;
  background-image: url("default-skin.png"); 
  display:inline-block;
  background-position: -80px -80px;
}
div.selectionIndicator {
  width:40px;
  height:40px;
  background-image: url("selected.png"); 
  display:none;
}
</style>
</head>
<body>
<div id="ballpen"></div>
<a href='#' id='logicLink'>logic</a>
<div id='palette'>
  
</div>
<a href='#' id='toolPencil' class='toolButton'>Pencil</a>
<a href='#' id='toolBrush' class='toolButton'>Brush</a>
<a href='#' id='toolFill' class='toolButton'>Fill</a>
<a href='#' id='toolWire' class='toolButton'>Wire</a>

<div style='height:30em;overflow:scroll' id='map'>



</div>

<input type='button' value='Export!' id='export' />
<input type='button' value='Save!' id='save' />

<script>
$(function() {
  var tileSize = 40;
  function positionCss(x, y) {
    return -x*tileSize + 'px ' + -y*tileSize + 'px';
  }
  function TileType(name, sheetX, sheetY, r,g,b, extra) {
    this.name = name;
    this.sheetX = sheetX;
    this.sheetY = sheetY;
    this.color = String.fromCharCode(r)+String.fromCharCode(g)+String.fromCharCode(b)+String.fromCharCode(255);
    this.postPlaceFn = extra&&extra.postPlaceFn;
    this.logicFn = extra&&extra.logicFn;
    this.image = extra&&extra.image;
  }
  TileType.prototype.positionCss = function() {
    return positionCss(this.sheetX, this.sheetY)
  }
  TileType.prototype.drawOn = function($elem, tile) {
    var styleBgColor = this.name == 'empty' ? 'black' : '';
    if (styleBgColor != $elem.styleBgColor) {
      $elem.css('background-color', styleBgColor);
      $elem.styleBgColor = styleBgColor;
    }
    var styleUrl = 'url("' + (this.image || 'default-skin') + '.png")';
    if (styleUrl != $elem.styleUrl) {
      $elem.css('background-image', styleUrl)
      $elem.styleUrl = styleUrl;
    }
    if (this == wallType && tile) {
      var x = tile.x, y = tile.y;
      var idx = (isWall(x-1,y)?1:0) | (isWall(x+1,y)?2:0) | (isWall(x,y-1)?4:0) | (isWall(x,y+1)?8:0);
      var coords = [
        [0,0], //
        [9,6], // L
        [8,6], // R
        [2,4], // LR
        [0,6], // U
        [6,8], // LU
        [2,8], // RU
        [4,8], // LRU
        [0,2],  // D
        [6,0], // LD
        [2,0], // RD
        [4,0], // LRD
        [4,1], // UD
        [7,4], // LUD
        [0,4], // RUD
        [4,4]  // LRUD
      ][idx];
      $elem.css('background-position', positionCss(coords[0], coords[1]))
    } else {
      $elem.css('background-position', this.positionCss())
    }
  }
  
  
  function Tool(fns) {
    this.down = fns.down || function() {};
    this.drag = fns.drag || function() {};
    this.up = fns.up || function() {};
    this.select = fns.select || function() {};
    this.unselect = fns.unselect || function() {};
  }
  var pencil = new Tool({
    drag: function(x,y) {
      tiles[x][y].setType(brushTileType);
    }
  });
  var brush = new Tool({
    drag: function(x,y) {
      for (var ix=x-1; ix<=x+1; ix++) {
        for (var iy=y-1; iy<=y+1; iy++) {
          if (ix>=0 && iy>=0 && ix<width && iy<height) {
            tiles[ix][iy].setType(brushTileType);
          }
        }
      }
    }
  });
  var fill = new Tool({
    drag: function(x,y) {
      console.log('filling with', brushTileType);
      var changed = {};
      changed[x + ' ' + y] = true;

      var toChange = [ tiles[x][y] ];
      var targetType = tiles[x][y].type;

      while (toChange.length > 0) {
        toChange.forEach(function(tile) {
          tile.setType(brushTileType);
        });

        var tempToChange = [];

        toChange.forEach(function(tile) {
          console.log('Expanding from', tile);
          for (var ix=tile.x-1; ix<=tile.x+1; ix++) {
            for (var iy=tile.y-1; iy<=tile.y+1; iy++) {
              if (Math.abs(tile.x-ix) + Math.abs(tile.y-iy) == 1&& ix>=0 && iy>=0 && ix<width && iy<height) {
                var test = tiles[ix][iy];
                console.log('Expanding to', test);
                if (test.type == targetType && !changed[ix + ' ' + iy]) {
                  tempToChange.push(test);
                  changed[ix + ' ' + iy] = true;
                }
              }
            }
          }
        });
        toChange = tempToChange;
        console.log('changed:', changed, 'toChange:', toChange);
      }
    }
  })
  var wire = new Tool({
    unselect: function() {
      clearHighlights();
      this.selectedSwitch = null;
    },
    down: function(x,y) {
      var tile = tiles[x][y];
      if (tile.type == portalType) {
        clearHighlights();
        if (this.selectedSwitch && this.selectedSwitch.type == portalType) { 
          this.selectedSwitch.destination = tile;
          this.selectedSwitch = null;
        } else {
          this.selectedSwitch = tile;
          tile.highlight(true);
          if (tile.destination) {
            tile.destination.highlight(true);
          }
        }
      } else if (tile.type == switchType) {
        this.selectedSwitch = tile;
        clearHighlights();
        tile.highlight(true);
        
        var sel = this.selectedSwitch.affected || ( this.selectedSwitch.affected={});
        for (var key in sel) {
          sel[key].highlight(true);
        }
      } else if (this.selectedSwitch && this.selectedSwitch.type == switchType) {
        var affected = this.selectedSwitch.affected || ( this.selectedSwitch.affected={});
        var key = x + ',' + y;
        if (affected[key]) {
          console.log('unselected');
          delete affected[key]
          tile.highlight(false);
          console.log('unselected', affected);
        } else {
          affected[key] = tile;
          tile.highlight(true);
          console.log('selected', affected);
        }
      }
    }
  });
  
  function clearHighlights() {
    $map.find('.selectionIndicator').css('display', 'none');
  }
  

  function ensureUnique(placedX, placedY) {
    for (var x=0; x<width; x++) {
      for (var y=0; y<height; y++) {
        if (x==placedX && y==placedY) continue;
        if (tiles[x][y].type == this) {
          tiles[x][y].setType(floorType);
        }
      }
    }
  }
  
  function setFieldFn(defaultState) {
    return function(logic, tile) {
      logic.fields[tile.x + ',' + tile.y] = {defaultState: defaultState};
    }
  }
  
  function exportSwitch(logic, tile) {
    var toggles = [];
    console.log(tile.affected);
    for (var key in tile.affected) {
      var affectedTile = tile.affected[key];
      var t = affectedTile.type;
      console.log(affectedTile, t);
      if (t==bombType || t==onFieldType || t==offFieldType || t==redFieldType || t.type==blueFieldType) {
        toggles.push({pos: {x: affectedTile.x, y: affectedTile.y}});
        console.log(toggles);
      }
    }
    logic.switches[tile.x + ',' + tile.y] = {toggle: toggles};
  }
  function exportPortal(logic, tile) {
    var dest = tile.destination || tile;
    logic.portals[tile.x + ',' + tile.y] = {destination: {x: dest.x, y: dest.y}};
  }
  
  var floorType, wallType, blueFlagType, redFlagType, switchType, bombType, onFieldType, offFieldType, redFieldType, blueFieldType, portalType;
  var tileTypes = [
    floorType = new TileType('floor', 2,2, 212,212,212),
    new TileType('empty', 0,1, 0,0,0),
    wallType = new TileType('wall', 0,0, 120,120,120),
    switchType = new TileType('switch', 2,5, 185,122,87, {logicFn: exportSwitch}),
    new TileType('spike', 2,3, 55,55,55),
    bombType=new TileType('bomb', 6,5, 255,128,0),
    new TileType('powerup', 7,8, 0,255,0),
    new TileType('speedpad', 0,0, 255,255,0, {image: 'speedpad'}),
    new TileType('blueSpeedpad', 0,0, 115,115,255, {image: 'speedpadblue'}),
    new TileType('redSpeedpad', 0,0, 255,115,115, {image: 'speedpadred'}),
    new TileType('redFloor', 3,1, 220,186,186),
    new TileType('blueFloor', 3,2 , 187,184,221),
    offFieldType = new TileType('offField', 10,1, 0,117,0, {logicFn: setFieldFn('off')}),
    onFieldType = new TileType('onField', 10,2, 0,117,0, {logicFn: setFieldFn('on')}),
    redFieldType = new TileType('redField', 10,3, 0,117,0, {logicFn: setFieldFn('red')}),
    blueFieldType = new TileType('blueField', 10,4, 0,117 ,0, {logicFn: setFieldFn('blue')}),
    portalType = new TileType('portal', 0,0, 202, 192, 0, {image: 'portal', logicFn: exportPortal}),
    redFlagType = new TileType('redFlag', 8,0, 255,0,0),
    blueFlagType = new TileType('blueFlag', 9,0, 0,0,255)
  ]

  function Tile() {
    
  }
  Tile.prototype.setType = function(type) {
    if  (this.type==type) return;
    this.type = type;
    type.drawOn(this.elem, this);
    if (type.postPlaceFn) {
      type.postPlaceFn.call(type, this.x, this.y);
    }
    
    maybeIsDirtyWall(this.x-1, this.y);
    maybeIsDirtyWall(this.x+1, this.y);
    maybeIsDirtyWall(this.x, this.y-1);
    maybeIsDirtyWall(this.x, this.y+1);
  }
  Tile.prototype.highlight = function(highlighted) {
    this.elem.find('.selectionIndicator').css('display', highlighted ? 'inline-block' : 'none');
  }

  
  var dirtyWalls = {};
  function isWall(x, y) {
    if (x<0 || y<0 || x>=width || y>=height) return false;
    return tiles[x][y].type == wallType;
  }
  function maybeIsDirtyWall(x, y) {
    if (isWall(x,y)) dirtyWalls[x + ' ' + y] = tiles[x][y];
  }
  function cleanDirtyWalls() {
    for (var key in dirtyWalls) {
      var wall = dirtyWalls[key];
      if (wall.type != wallType) continue;
      
      console.log('cleaning', wall);
      wall.type.drawOn(wall.elem, wall);
    }
    dirtyWalls = {};
  }
  
  var $map = $('#map');
  var $palette = $('#palette');
  var height = 20;
  var width = 10;
  var html = '';
  var row = "<div class='tileRow'>";
  
  var brushTileType = tileTypes[0];
  
  for (var x=0; x<width; x++) {
    row += "<div class='tileBackground'><div class='tile'><div class='selectionIndicator'></div></div></div>";
  }
  row += "</div>"
  for (var y=0; y<height; y++) {
    html += row;
  }
  console.log(row)
  $map.html( html );
  
  var $tiles = $map.find('.tile');
  var tiles = [];
  
  for (var x=0; x<width; x++) {
    tiles[x] = [];
    for (var y=0; y<height; y++) {
      var $tile = $($tiles[y*width + x]).data('x', x).data('y', y);
      tiles[x][y] = new Tile();
      tiles[x][y].elem = $tile;
      tiles[x][y].type = brushTileType;
      tiles[x][y].x = x;
      tiles[x][y].y = y;
      brushTileType.drawOn($tile, tiles[x][y]);
    }
  }
  
  var selectedTool = pencil;
  
  var mouseDown = false;
  $map.on('mousedown', '.tile', function(e) {
    if (e.which==1) {
      mouseDown = true;
      var x = $(this).data('x');
      var y = $(this).data('y');
      selectedTool.down.call(selectedTool, x,y);
      selectedTool.drag.call(selectedTool, x,y);
      cleanDirtyWalls();
      e.preventDefault();
    }
  })
  .on('mousemove', '.tile', function() {
    if (mouseDown) {
      var x = $(this).data('x');
      var y = $(this).data('y');
      selectedTool.drag.call(selectedTool, x,y);
      cleanDirtyWalls();
    }
  })
  .on('mouseup', '.tile', function(e) {
    if (e.which==1) {
      mouseDown = false;
      cleanDirtyWalls();
    }
  });
  
  var wall = String.fromCharCode(120)+String.fromCharCode(120)+String.fromCharCode(120)+String.fromCharCode(255);
  var open = String.fromCharCode(212)+String.fromCharCode(212)+String.fromCharCode(212)+String.fromCharCode(255);
  function createPng() {
    var text = '';
    for (var y=0; y<height; y++) {
      for (var x=0; x<width; x++) {
        text += tiles[x][y].type.color;
      }
    }
    return text;
  }
  
  function makeLogic() {
    var logic = {
      info: {
        name: 'Untitled',
        author: 'Anonymous'
      },
      switches: {},
      fields: {},
      portals: {}
    };
      
    for (var x=0; x<width; x++) {
      for (var y=0; y<height; y++) {
        var fn = tiles[x][y].type.logicFn;
        if (fn) fn(logic, tiles[x][y])
      }
    }
    console.log(logic);
    return logic;
  }
  
  function extractMap() {
    var map = {};
    map.tiles = [];
    for (var y=0; y<height; y++) {
      var row = map.tiles[y] = [];
      for (var x=0; x<width; x++) {
        var tile = tiles[x][y];
        var cell;
        if (tile.type == portalType) {
          cell = {
            type: tile.type.name,
            destination: tile.destination ? [tile.destination.x, tile.destination.y] : [x,y]
          }
        } else if (tile.type == switchType) {
          var targets = [];
          for (var key in tile.affected||[]) {
            var affected = tile.affected[key];
            targets.push([affected.x, affected.y])
          }
          cell = {
            type: tile.type.name,
            targets: targets
          }
        } else {
          cell = tile.type.name;
        }
        row[x] = cell;
      }
    }
    return map;
  }
  
  $('#export').click(function() {
    console.log('exporting')
    var 
      pngData,
      pngFile,
      base64png,
      dataUrl = 'data:image/png;base64,',
      logicUrl = 'data:application/json;base64,',
      img,
      ballpen;

    pngData	= createPng();
    pngFile = generatePng(width, height, pngData);
    
    base64png = Base64.encode(pngFile);
    dataUrl += base64png;

    logicUrl += Base64.encode(JSON.stringify(makeLogic()));
    
    img = document.createElement("img");
    img.src = dataUrl;
    img.style.float = "left";
    img.style.left = "0";
    img.style.top = "0";
    img.style.zIndex = "2";
    ballpen = document.getElementById("ballpen");
    ballpen.insertBefore(img, ballpen.firstChild);
    
    $('#logicLink').attr('href', logicUrl);
  });
  
  $('#save').click(function() {
    var map = extractMap();
    console.log(map);
  });
  
  $.each(tileTypes, function(idx, type) {
    var $button = $("<div class='tileBackground'><div class='tile'></div></div>");
    type.drawOn($button.find('.tile'));
    $button.click('click', function() {
      brushTileType = type;
      console.log('sel', type);
      
    });
    $palette.append($button);
  });
  
  $('#toolPencil').data('tool', pencil);
  $('#toolBrush').data('tool', brush);
  $('#toolFill').data('tool', fill);
  $('#toolWire').data('tool', wire);
  $('.toolButton').click(function() {
    selectedTool.unselect.call(selectedTool)
    selectedTool = $(this).data('tool');
    selectedTool.select.call(selectedTool);
  })
});
</script>
</body></html>